#!/usr/bin/env python3
"""Test program to connect to the Roku Perfetto endpoint and
download a Perfetto capture.
"""
import argparse
import asyncio
import json
import subprocess
import sys
import xml.etree.ElementTree as ET
from datetime import datetime

import httpx
import websockets

from typing import Optional


async def dump_binary(
    ws_url: str,
    out_path: str,
    log: bool,
):
    """Connect to the given WebSocket URL and dump binary messages to the given file."""
    try:
        async with websockets.connect(ws_url) as ws:
            with open(out_path, "ab") as f:
                if log:
                    print(f"Connected. Writing to {out_path}")
                async for msg in ws:
                    if isinstance(msg, bytes):
                        f.write(msg)
                        if log:
                            print(f"Binary frame: {len(msg)} bytes")

    except websockets.exceptions.InvalidStatus as e:
        print(f"Failed to connect to device's websocket: [{e}]", file=sys.stderr)

    except Exception as e:
        print(f"Websocket error: [{e}]", file=sys.stderr)


def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument("ip")
    p.add_argument("--log", action="store_true", help="Print info about frames")
    p.add_argument(
        "--validate", action="store_true", help="Validate recorded trace using `protoc`"
    )
    # create a list of channels to enable on startup
    p.add_argument(
        "--channel", action="append", help="Enable the given channel on startup"
    )
    return p.parse_args()


def get_esn(ip: str) -> Optional[str]:
    """Get the device ESN using the device-info endpoint"""
    with httpx.Client() as client:
        resp = client.get(f"http://{ip}:8060/query/device-info")
        resp.raise_for_status()
        # response is XML, parse it to find the device-id:
        tree = ET.fromstring(resp.text)
        esn = tree.find("serial-number")
        if esn is not None:
            return esn.text

    return None


def main():
    args = parse_args()

    # Create the output filename by appending the current date/time to the prefix
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    esn = get_esn(args.ip) or "noesn"
    outfile = f"trace.{esn}.{timestamp}.bin"

    url = f"ws://{args.ip}:8060/perfetto-session"

    if args.channel:
        # Enable the given channels using the perfetto-enable-channel endpoint
        with httpx.Client() as client:
            for channel in args.channel:
                resp = client.post(f"http://{args.ip}:8060/perfetto/enable/{channel}")
                resp.raise_for_status()
                tree = ET.fromstring(resp.text)
                error = tree.find("error")
                if error is not None:
                    sys.exit(f"Failed to enable channel {channel}: {error.text}")

                if args.log:
                    print(f"Enabled channel {channel}")

    if args.validate:
        # Check that `protoc` is available
        try:
            subprocess.run(["protoc", "--version"], check=True, capture_output=True)
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            print(
                "Error: `protoc` is not available. Please install the Protocol Buffers compiler.",
                file=sys.stderr,
            )
            sys.exit(1)
        print("`protoc` is available.")
        protoc_child = subprocess.Popen(
            ["protoc", "--decode_raw"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )

    # trap Ctrl-C and exit gracefully, validating the trace if requested
    try:
        asyncio.run(
            dump_binary(
                url,
                outfile,
                args.log,
            )
        )
    except KeyboardInterrupt:
        print("Interrupted, exiting...")
    if args.validate:
        subprocess.check_call(
            ["protoc", "--decode_raw"],
            stdin=open(outfile, "rb"),
            stdout=subprocess.DEVNULL,
            stderr=sys.stderr,
        )

if __name__ == "__main__":
    main()
